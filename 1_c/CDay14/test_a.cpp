// 总结各个排序算法的特性 (时间复杂度，空间复杂度和稳定性)。

// 排序算法特性总表
// 排序算法	平均时间复杂度	最坏时间复杂度	最好时间复杂度	空间复杂度	稳定性	核心特点
// 冒泡排序	O(n²)	O(n²)	O(n)	O(1)	✅ 稳定	简单、相邻交换
// 选择排序	O(n²)	O(n²)	O(n²)	O(1)	❌ 不稳定	选最小元素交换，非相邻交换不稳定
// 插入排序	O(n²)	O(n²)	O(n)	O(1)	✅ 稳定	适合小数据或基本有序
// 希尔排序	O(n log n)	O(n²)	O(n log n)	O(1)	❌ 不稳定	插入排序改进，分组排序
// 归并排序	O(n log n)	O(n log n)	O(n log n)	O(n)	✅ 稳定	分治思想，需额外空间
// 快速排序	O(n log n)	O(n²)	O(n log n)	O(log n)~O(n)	❌ 不稳定	分治+基准，递归栈空间
// 堆排序	O(n log n)	O(n log n)	O(n log n)	O(1)	❌ 不稳定	二叉堆结构，原地排序
// 计数排序	O(n + k)	O(n + k)	O(n + k)	O(n + k)	✅ 稳定	非比较，k为数据范围
// 桶排序	O(n + k)	O(n²)	O(n)	O(n + k)	✅ 稳定	数据均匀分布时高效
// 基数排序	O(d(n + b))	O(d(n + b))	O(d(n + b))	O(n + b)	✅ 稳定	按位排序，d为位数，b为基数
// 注：

// 稳定性：相同元素排序后相对位置不变（✅稳定，❌不稳定）。

// 空间复杂度：除递归栈开销外，是否需额外存储空间（如归并排序需 O(n) 辅助数组）。

// k：计数排序中数据的取值范围（非负整数）。

// d：基数排序中最大数字的位数。

// b：基数排序中采用的基数（如十进制 b=10）。

// 关键特性详解
// 稳定性

// 稳定算法：冒泡、插入、归并、计数、桶排序、基数排序。

// 不稳定算法：选择、希尔、快速、堆排序（存在非相邻交换或跳跃移动）。

// 时间复杂度

// O(n²)：冒泡、选择、插入（小数据量高效）。

// O(n log n)：希尔、归并、快排、堆排（大数据量首选）。

// 线性排序：计数、桶、基数排序（需满足特定数据条件）。

// 空间复杂度

// 原地排序（O(1)）：冒泡、选择、插入、希尔、堆排序。

// 需额外空间：

// 归并排序 → O(n)（辅助数组）

// 快速排序 → O(log n)（递归栈）

// 非比较排序 → O(n + k) 或 O(n + b)（存储桶或计数数组）。

// 适用场景建议
// 小数据量（n ≤ 100）：插入排序（稳定且简单）。

// 大数据量且需稳定：归并排序（牺牲空间换稳定）。

// 大数据量且内存敏感：堆排序（原地排序 + O(n log n)）。

// 数据范围有限（如整数）：计数排序/基数排序（接近线性时间）。

// 通用高效方案：快速排序（实际应用中最快，但需避免最坏情况）。

// 稳定性应用场景：如对学生成绩先按分数排序，再按学号排序时，需保持同分学生的原始学号顺序（稳定算法可保留多轮排序的关联性）。